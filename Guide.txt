[SIZE="6"][FONT="Franklin Gothic Medium"][B]CS:GO Cheat Making 101[/B][/FONT][/SIZE]
[B][I]
NOTE: This guide is still a HUGE work in progress. You can use the GitHub repo to push commits in order to modify and update this guide. Your help is important! [URL="https://github.com/DoubleHub/CSGOCheatMaking101/blob/master/Guide.txt"]*CLICK*[/URL][/I][/B]

[B][I]Structure of the guide:[/I][/B] (prone to changes)
[B]Chapter 0[/B] ~ Welcome to CS:GO Cheat Making 101! The requirements
[B]Chapter 1[/B] ~ Explaining CS:GO
[I]Chapter 1.1[/I] ~ Brief introduction to the Source Engine
[I]Chapter 1.2[/I] ~ Different types of cheats
[I]Chapter 1.3[/I] ~ Talking about VAC: Ring0 and Ring3
[B]Chapter 2[/B] ~ External Cheats: The starting point
[I]Chapter 2.1[/I] ~ Brief introduction to WinAPI
[I]Chapter 2.2[/I] ~ Managing CS:GO memory: RPM and WPM
[I]Chapter 2.3[/I] ~ Getting CS:GO module info
[I]Chapter 2.4[/I] ~ Building a memory management class
[B]Chapter 3[/B] ~ Offsets
[I]Chapter 3.1[/I] ~ Using our class and the offsets to make our first bhop
[I]Chapter 3.2[/I] ~ Netvars
[I]Chapter 3.3[/I] ~ Getting offsets dynamically: Pattern Scanning
[I]Chapter 3.4[/I] ~ Getting netvars dynamically: Netvar Managers and recursion
[B]Chapter 4[/B] ~ Internal Cheats: The advantages
[I]Chapter 4.1[/I] ~ Calling exported module functions
[I]Chapter 4.2[/I] ~ CreateInterface: Getting those interfaces
[I]Chapter 4.3[/I] ~ Hooking methods: VMT hooking
[I]Chapter 4.4[/I] ~ A look at the Source SDK
[I]Chapter 4.5[/I] ~ Common functions to hook
[I]Chapter 4.6[/I] ~ A look at CreateMove: Making our first internal bhop
[I]Chapter 4.7[/I] ~ Drawing using ISurface

[SIZE="5"][FONT="Franklin Gothic Medium"][B]Chapter 0[/B][/FONT][/SIZE]
[SIZE="4"][FONT="Franklin Gothic Medium"][B]Welcome to CS:GO Cheat Making 101! The requirements[/B][/FONT][/SIZE]

Hi and welcome to CS:GO Cheat Making 101, an "all-in-one" guide on CS:GO cheat making! Please notice that this guide is still a huge work in progress and it is prone to changes. Since I'm not really pro when it comes to CS:GO cheat making I'd like you guys to help me building this guide and expanding it to be as large as possible. I'll cover a lot (but not all) of the aspects of CS:GO cheats and I'll try to be as clear as possible.

Now let's take a look at the requirements for this guide. I see many people here trying to approach CS:GO cheat making (in various languages) just to make cheats for them. I mean that's great, you want to learn but that's not the right approach. If you have absolutely zero knowledge of programming in general following this guide will be really difficult so I expect from you to know at least one programming language and being able to think in terms of programming, you know what I mean.
Some people here even learnt a programming language by making CS:GO cheats but still, it will be really difficult if you don't have a certain "mindset" already.

I'm not writing this guide with the purpose of showing my (little) knowledge about this stuff. I'm writing this guide as a starting point to many ppl out there trying to get started in this sector. As I said some months ago, all I needed when I started here was a solid base to learn from. In order to make this guide one of the best and the most complete guide about CS:GO cheat making I need your help. The help of people with much experience in this sector which would be really great and you would definetely help this community. :asskiss:

[SIZE="5"][FONT="Franklin Gothic Medium"][B]Chapter 1[/B][/FONT][/SIZE]
[SIZE="4"][FONT="Franklin Gothic Medium"][B]Explaining CS:GO[/B][/FONT][/SIZE]

[B]C[/B]ounter [B]S[/B]trike: [B]G[/B]lobal [B]O[/B]ffensive (aka CS:GO) as many of you know is a first person shooter with a lot of focus on the competitive aspect. The game requires a certain set of skills and ability to pwn your enemies and when it's about skill we all know that... we'll come to cheats! CS:GO is probably one of the most (if not the most) full of cheaters paid game and the creators (Valve + Hidden Path Entertainment) can't do anything about it. Throughout the various updates of the game they've released several ways and workarounds to stop cheaters (which are most of the time failing) but in the end we all know that they won't stop cheaters and for obvious money reasons: Getting a cheap copy of CS:GO is easy as it is to cheat. There are near to no protections compared to other paid games (well, don't take me wrong there are some cheap protections like untrusted checks but...) and the community itself is full of cheaters. Just for example this section of UC is probably one of the most visited and active sections on UC (mods, get ready to prove the opposite).

But we are not here to talk about how full of cheaters CS:GO is, we are here to learn about making a cheat! This forum is full of references, tutorials and sources about how to make certain stuff for CS:GO. In fact I'll put a little list of reference links at the end of each chapter which I really recommend reading to understand the concept explained in the chapter better.

Reference links for this section:
[url]http://www.unknowncheats.me/wiki/Counter-Strike:_Global_Offensive[/url]
[url]https://en.wikipedia.org/wiki/Counter-Strike:_Global_Offensive[/url]
[url]https://en.wikipedia.org/wiki/Valve_Corporation[/url]
[url]https://en.wikipedia.org/wiki/Hidden_Path_Entertainment[/url]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Brief introduction to the Source Engine[/B][/I][/FONT][/SIZE]

CS:GO is based on the Source Engine a really famous game engine used to make a lot of games that we all know and love (a prime example is Half Life or Left 4 Dead).
The Source Engine is well known for his great physics system (that we saw in action in HL) but in general it is a great engine to make games on. Another big advantage is it's flexibility which makes the life of modders way easier.

Also it's documented very good on internet and here and it's (even if partly) open source. This allows us to get a shit-ton of info about the game itself without needing to reverse it completely (don't get me wrong, you'll still need to reverse it on certain situations).
Since CS:GO is built upon the Source Engine a large part of what we have to do to modify the game (to get an advantage) is related to it especially when we are going internal.

Reference links for this section:
[url]http://www.unknowncheats.me/wiki/Source_Engine[/url]
[url]https://en.wikipedia.org/wiki/Source_(game_engine)[/url]
[url]https://developer.valvesoftware.com/wiki/SDK_Docs[/url]
[url]https://github.com/ValveSoftware/source-sdk-2013[/url]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Different types of cheats[/B][/I][/FONT][/SIZE]

Before getting into cheat making it's important to know what are we going to do.
Usually (not only for CS:GO) there are 2 types of cheats: Internals and Externals.
The difference between those two types is huge:

An [B]EXTERNAL[/B] cheat is an [B]EXE[/B] which is able to read and write memory to the CS:GO process through a HANDLE (think of it like a bridge). By reading and writing to certain areas of the process memory we are able to make changes which give us an advantage over other players.
The main disadvantage of externals is the fact that we are not in sync with the game's thread which can lead to "unexpected" results (a prime example are external skinchangers: since they are not in sync with the game's thread you won't achieve consistency especially when trying to change the knife model).
We are also forced to read and write through specific functions (which we'll see later) that are heavy to call.

An [B]INTERNAL[/B] cheat is a [B]DLL[/B] which is injected directly into CS:GO and is able to directly read and write CS:GO memory through raw pointers. Internally we can also get interfaces and call virtual functions which makes our lifes way easier. We can also hook some functions to kind of "redirect" them and make them do what we want.

There is still an open discussion about what type of cheat is the most detectable.

There is another type of cheat called "Internal/External" which is basically a DLL which is injected into any 32-bit process and from there it operates like a normal external. I think that we can consider this type of cheat external because in the end all the operations we do are the same as external and we don't do anything internal.

We'll start with external which are easier to learn but harder to master while internal cheats are harder to learn... but easier to master!

Reference links for this section:
[URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/151797-ezfrags-cs-multihack-public-rage-legit.html"]An example of an external cheat (EZFrags)[/URL]
[URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/183376-fx-cs-public-release.html"]An example of an internal cheat (FX)[/URL]
[URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/159299-internal-external-customizable-multi-hack.html"]An example of an internal/external cheat[/URL]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Talking about VAC: Ring0 and Ring3[/B][/I][/FONT][/SIZE]
[I]
(NOTE: I may say something wrong or bullshit in this specific section. VAC experts and kernel mode experts, help me! <3)[/I]

The main anticheat which CS:GO is using is the [B]V[/B]alve [B]A[/B]nti-[B]C[/B]heat (aka VAC) which is supposed to block cheaters but we all know that it fails most of the time. Basically VAC is a joke. You don't need to be too afraid of it since it won't bust you if you aren't using a public cheat. VAC is using signature scanning in order to detect cheats. SO when a cheat becomes detected by VAC it means that the VAC detected its signature (which is an unique identifier for a program in the RAM) and stored it in the VAC database. When you are using a cheat with a detected signature you are f*cked (flagged).
VAC bans are completely automatic and can take a lot of time to ban you because it needs to know 100% that you are cheating in order to avoid false positives.

You need to know about protection rings to get a feeling about how VAC is such a joke. Basically, Intel processors (x86 but also others) provide some sort of privilege levels (0 being most privilege and 3 being last) aka UserMode and KernelMode in form of protection rings to protect critical resources like IO, memory, ports, etc.
So the processor runs the kernel code of the OS(the core of the OS) inside Ring0 and user code(normal applications like Spotify, Steam, etc.) inside Ring3.
VAC operates in Ring3. That basically(really basic) means if you make a Ring0 cheat you are good to go. So if you are capable of making a Ring0 cheat then all of this stuff should be a piece of cake at your eyes you can leave.

Reference links for this section:
[url]https://en.wikipedia.org/wiki/Valve_Anti-Cheat[/url]
[url]http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection/[/url]
[url]https://en.wikipedia.org/wiki/Protection_ring[/url]

[SIZE="5"][FONT="Franklin Gothic Medium"][B]Chapter 2[/B][/FONT][/SIZE]
[SIZE="4"][FONT="Franklin Gothic Medium"][B]External Cheats: The starting point[/B][/FONT][/SIZE]

We'll focus on external cheats for now which you now know what they do (ref: 1.2 Different types of cheats)
Writing external cheats serves as a really good starting point in this sector because externals are way more documented than internals and they are easier to code and understand.
However, once you get a really good grip on this type of cheat you should consider switching to an internal one which is (imho) fairly better. Still, you need the right knowledge.

As I already explained the method external cheats use is to read and write to the CS:GO memory in order to edit it, gain info and get a huge advantage over our enemies in game.
An external cheat however isn't forced to manage CS:GO memory. You can write a really good recoil control system (aka RCS) without needing to read or write anything for example. Still, the most consistent results can be achieved only by reading/writing to memory. You can make a bhop script that spams the space key without reading or writing any sector of memory for example but still the hops won't be consistent and the result can be shit. On the other side by reading the memory to know exactly when to jump you can achieve the consistency you want.
In the end, it's all a matter of consistency.

Reference links for this section:
[URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/147103-peans-ahk-triggerbot-aka-colorbot-extension.html"]An example of color triggerbot, not interacting with CS:GO memory[/URL]
[URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/168179-simple-bunny-hop-script.html"]An example of a really basic bhop, interacting with CS:GO memory (by me)[/URL]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Brief introduction to the WinAPI[/B][/I][/FONT][/SIZE]

As I've stated above we need to manage CS:GO memory in order to achieve results with our external cheat. But how? The answer has got a name: The [B]Win[/B]dows [B]A[/B]pplication [B]P[/B]rogramming [B]I[/B]nterface! (WinAPI)

Windows allows us to use the WinAPI which Microsoft's core set of APIs which are focused on the programming language C and implemented in [B]D[/B]ynamic [B]L[/B]ink [B]L[/B]ibraries (DLLs). Don't get me wrong, you can use the WinAPI in C++ or other languages, too.
There are three groups of WinAPI functions that interest us(there are mainly 8): the Base Services, the [B]G[/B]raphics [B]D[/B]evice [B]I[/B]nterface (GDI) and the UserInterface.  If you want to get deeper you can find more infos about the WinAPIs on the reference links down below.

Now that we know what we are mainly going use in our externals we can start talking about practically managing the CS:GO memory!

Reference links for this section:
[url]https://en.wikipedia.org/wiki/Windows_API[/url]
[url]https://msdn.microsoft.com/en-us/library/cc433218(VS.85).aspx[/url]
[url]http://www.infernodevelopment.com/c-win32-api-tutorial[/url]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Managing CS:GO memory: RPM and WPM[/B][/I][/FONT][/SIZE]

We're going to use a lot of stuff from the WinAPI to get the results we want and the functions that we are going to use the most are the actual functions to read and write process memory.
Those two functions are [B]R[/B]ead[B]P[/B]rocess[B]M[/B]emory and [B]W[/B]rite[B]P[/B]rocess[B]M[/B]emory (RPM and WPM).
Let's see how we work with these two functions.
I'll start with ReadProcessMemory. Based on the MSDN page of RPM, the function prototype is:

[CODE]
BOOL WINAPI ReadProcessMemory(
  _In_  HANDLE  hProcess,
  _In_  LPCVOID lpBaseAddress,
  _Out_ LPVOID  lpBuffer,
  _In_  SIZE_T  nSize,
  _Out_ SIZE_T  *lpNumberOfBytesRead
);
[/CODE]

[I]"_In_  HANDLE  hProcess"[/I]

The first argument, hProcess, is the actual [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724176(v=vs.85).aspx"]HANDLE[/URL] to the process we want to read memory from. Remember what I said in 1.2? In external cheats we use a HANDLE (like a bridge) to read and write memory.
In order to get this HANDLE you've got several ways. 
The most used way is to loop through all the process with the function [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684836(v=vs.85).aspx"]Process32Next[/URL] (and [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684834(v=vs.85).aspx"]Process32First[/URL]) using the helper struct [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684839(v=vs.85).aspx"]PROCESSENTRY32[/URL] and then comparing names of the processes with the process name we are searching for in a loop. Ff the names are the same then we use the WinAPI function [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684320(v=vs.85).aspx"]OpenProcess[/URL] to open a handle to this process. Notice that we will put the flag [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684880(v=vs.85).aspx"]PROCESS_ALL_ACCESS[/URL] to gain full privileges to the process in order to be able to read and write.

[B]REMEMBER! A HANDLE must always be closed through [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms724211(v=vs.85).aspx"]CloseHandle[/URL] once it's not used anymore![/B]

This however is not the only way of course. For example if we are using managed languages like C# or VB.NET there are way easier ways. However I've explained the most common one.

The other arguments are already well explained on the MSDN page and you'll later see how to use the second argument with module base addresses and offsets.

WPM has got the same arguments but with the difference that the third argument is a pointer pointing to the value we want to write while in RPM it's a pointer pointing to the variable that is gonna receive the value read from memory.

RPM and WPM are not the only way to read and write process memory they're just the most common ones since they're well documented and already implemented by the WinAPI itself. CS:GO doesn't detect WPM and RPM since a lot of legit processes use them constantly and the anticheat (as I already stated) wants to avoid false positives.

Reference links for this section:
[URL="http://pastebin.com/Bd6t5tcP"]Commented example of a common function to open an handle to a process (using WinAPI)[/URL]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Getting CS:GO module infos[/B][/I][/FONT][/SIZE]

One of the most useful things we can do in CS:GO memory is grabbing infos about a specific module (a DLL like client.dll or engine.dll but also others). When we'll get into offsets you'll see how important it is to know some stuff about different CS:GO modules. But how can we grab this useful info?
As always there are several methods. One is really similar to the method that I've explained previously about opening the process handle. The only difference being that instead of using [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684839(v=vs.85).aspx"]PROCESSENTRY32[/URL] and related funcs like [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684834(v=vs.85).aspx"]Process32First[/URL] and [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684836(v=vs.85).aspx"]Process32Next[/URL] we will use [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684225(v=vs.85).aspx"]MODULEENTRY32[/URL] to store info and [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684218(v=vs.85).aspx"]Module32First[/URL]/[URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684221(v=vs.85).aspx"]Next[/URL] to loop through the module list.

Another way is to use the [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684229(v=vs.85).aspx"]MODULEINFO[/URL] structure and [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms683201(v=vs.85).aspx"]GetModuleInformation[/URL] function - really handy when it comes to this kind of stuff.

Now that we got the info that we want we can use the base address of the module to access specific things (using offsets) in that module (for example grabbing the local player or the local player health value).
Another useful thing to know is the module size you'll see its importance when I talk about pattern scanning.

Reference links for this section:
[URL="http://pastebin.com/GC9kTHcJ"]Commented example of a common function to get module info (using WinAPI)[/URL]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Building a memory management class[/B][/I][/FONT][/SIZE]
[I]
(NOTE: This section is going to get really practical with a lot of of C++ source code(commented ofc). But no problems, it's optional! You can skip this if you really want it <3)[/I]

Now that you know what we need to do in order to have fun within CS:GO memory you can take it a step further and start to code an actual class to make everything easier to do. Our goal is to make a memory management class (aka MMC) that allows us to attach to a specific process and grab modules. It's also going to contain some useful template wrappers to WPM and RPM so everything will be easier.

Don't take me wrong, you don't actually NEED this kind of class you can just go ahead and use raw RPM/WPM or just build the functions and use them without using a class but imho setting it up using OOP is going to help us.
In this guide I'm going to use C++ as an example language but that's not a problem since you can do the same things (with some little changes :P) using other languages like C#.

So let's go ahead, this class will contain some members ofc!

[CODE]
class CMemoryManager
{
private: // Private members: We are going to setup some getters later on!
	HANDLE m_hProcess; // The HANDLE to the process to attach
	DWORD m_dwProcessId; // The Process ID of the process to attach
	std::vector<MODULEENTRY32> m_Modules; // std::vector containing all the modules we grab from the process
[/CODE]

As you can see we got [I]m_hProcess[/I] which is basically the HANDLE to the process to attach, [I]m_dwProcessId[/I] which is the process ID of the process to attach and a basic std::vector of MODULEENTRY32 structs which is going to contain all the modules we grab from the attached process. We use an std::vector so it's easier to push back new elements (modules) without worrying too much about fixed sizes.
Now let's make the public functions:

[CODE]
        // Attach to a process based on strProcessName
	// Returns true on success, false on failure
	bool Attach(const std::string& strProcessName)
	{
	    // First of all we create a snapshot handle for processes
	    // (notice the usage of TH32CS_SNAPPROCESS) so we are able to call Process32First/Next
	    // Remember to close it when you don't use it anymore!
	    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	    // Check if the snapshot created is valid
	    if (hSnapshot == INVALID_HANDLE_VALUE) return false;
	   
	    // Create the helper struct that will contain all the infos about the current process
	    // while we loop through all the running processes
	    PROCESSENTRY32 ProcEntry;
	    // Remember to set the dwSize member of ProcEntry to sizeof(PROCESSENTRY32)
	    ProcEntry.dwSize = sizeof(PROCESSENTRY32);
	   
	    // Call Process32First
	    if (Process32First(hSnapshot, &ProcEntry))
	    {
	        // Notice that you have to enable Multi-Byte character set in order
	        // to avoid converting everything.
	        // strcmp is not the only way to compare 2 strings ofc, work with your imagination
	        if (!strcmp(ProcEntry.szExeFile, strProcessName.c_str()))
	        {
	            // If we are here it means that the process has been found and we can
	            // open an handle to it and return it
	            // but first of all we have to close the snapshot handle!
	            CloseHandle(hSnapshot);
	            // Open an handle and set the m_hProcess member using OpenProcess
	            // (Notice the usage of PROCESS_ALL_ACCESS flag in order to get read/write privileges)
	            m_hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcEntry.th32ProcessID);
	            // Store the process ID into m_dwProcessId
	            m_dwProcessId = ProcEntry.th32ProcessID);
	            // Return true to signal success
	            return true;
	        }
	    }
	    else
	    {
	        // If the Process32First call failed, it means that there is no
	        // process running in the first place so we can return directly.
	        CloseHandle(hSnapshot);
	        return false;
	    }
	   
	    // If we are here it means that the Process32First call returned TRUE, but the first process
	    // wasn't the process we were searching for. Now we can loop through the processes
	    // using Process32Next
            while (Process32Next(hSnapshot, &ProcEntry))
            {
	        // We do the same check we did for Process32First
	        if (!strcmp(ProcEntry.szExeFile, strProcessName.c_str()))
	        {
	            // If we are here it means that the process has been found and we can
	            // open an handle to it and set the m_hProcess member using OpenProcess
	            // (Notice the usage of PROCESS_ALL_ACCESS flag in order to get read/write privileges)
	            m_hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcEntry.th32ProcessID);
	            // Store the process ID into m_dwProcessId
	            m_dwProcessId = ProcEntry.th32ProcessID);
	            // Return true to signal success
	            return true;
	        }
	    }
	    // Continue loop while the Process32Next call returns TRUE meaning that there are still processes to check
	   
	    // If we are here it means that the process has not been found and that there are no processes to scan for anymore.
	    // We can close the snapshot handle and return false.
	    CloseHandle(hSnapshot);
	    return false;
	}
[/CODE]

Since I'm using C++ and WinAPI I'm using the exact same algorithm showed on the previous sections with some little modifies on the return values, functions and comments.
The same thing can be done with the function to grab a new module from the process:

[CODE]
// Grabs a module and adds it to m_Modules based on strModuleName
	// Returns true on success, false on failure
	bool GrabModule(const std::string& strModuleName)
	{
	    // First of all we create a snapshot handle specific for modules
	    // (notice the usage of TH32CS_SNAPMODULE) so we are able to call Module32First/Next
	    // Remember to close it when you don't use it anymore!
	    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, m_dwProcessId);
	    // Check if the snapshot created is valid
	    if (hSnapshot == INVALID_HANDLE_VALUE) return false;
	   
	    // Create the helper struct that will contain all the infos about the current module
	    // while we loop through all the loaded modules
	    MODULEENTRY32 ModEntry;
	    // Remember to set the dwSize member of ModEntry to sizeof(MODULEENTRY32)
	    ModEntry.dwSize = sizeof(MODULEENTRY32);
	   
	    // Call Module32First
	    if (Module32First(hSnapshot, &ModEntry))
	    {
	        // Notice that you have to enable Multi-Byte character set in order
	        // to avoid converting everything.
	        // strcmp is not the only way to compare 2 strings ofc, work with your imagination
	        if (!strcmp(ModEntry.szModule, strModuleName.c_str()))
	        {
	            // If we are here it means that the module has been found and we can add the module to the vector
	            // but first of all we have to close the snapshot handle!
	            CloseHandle(hSnapshot);
	            // Add ModEntry to the m_Modules vector
	            m_Modules.push_back(ModEntry); // You can add a check here to see if the module is already there ;)
	            // Return true to signal success
	            return true;
	        }
	    }
	    else
	    {
	        // If the Process32First call failed it means that there is no
	        // process running in the first place and we can return directly.
	        CloseHandle(hSnapshot);
	        return false;
	    }
	   
	    // If we are here it means that the Module32First call returned TRUE but the first module
	    // wasn't the module that we were searching for. Now we can loop through the modules
	    // using Module32Next
            while (Module32Next(hSnapshot, &ModEntry))
	    {
	        // We do the same check we did for Module32First
	        if (!strcmp(ModEntry.szModule, strModuleName.c_str()))
	        {
	            // If we are here it means that the module has been found and we can add the module to the vector
	            // but first of all we have to close the snapshot handle!
	            CloseHandle(hSnapshot);
	            // Add ModEntry to the m_Modules vector
	            m_Modules.push_back(ModEntry); // You can add a check here to see if the module is already there ;)
	            // Return true to signal success
	            return true;
	        }
	    }
	    // Continue loop while the Module32Next call returns TRUE meaning that there are still modules to check
	   
	    // If we are here it means that the module has not been found and there are no modules to scan for anymore.
	    // We can close the snapshot handle and return false.
	    CloseHandle(hSnapshot);
	    return false;
	}
[/CODE]

As you can see it's the exact same algorithm with some little modifications! Again, this isn't the only way to do this depending on what you are using.

Now that we've got the core functions that will perform the algorithms we need we can build our constructor which will initialize the class. As always everything is pretty straight forward and commented.

[CODE]
        // Default constructor: won't attach to any process
	CMemoryManager()
	{
		// Init members
		m_hProcess = INVALID_HANDLE_VALUE;
		m_dwProcessId = 0;
		// I clear out the modules vector just for safety
		m_Modules.clear();
	}
	// This constructor will attach to a specific process (default CS:GO)
	CMemoryManager(const std::string& strProcessName = "csgo.exe")
	{
		// Init members
		m_hProcess = INVALID_HANDLE_VALUE;
		m_dwProcessId = 0;
		// I clear out the modules vector for safety
		m_Modules.clear();
		// Attach and throw if the function failed so we can manage the fail
		if (!Attach(strProcessName))
			throw;
	}
[/CODE]

Now we can start writing our RPM/WPM wrappers. I'll stay simple for now but you can get further by adding things like reading a fixed size of memory, reading an array and returning a pointer to it and so on... just use your imagination! :)

[CODE]
// RPM/WPM wrappers
	
	// Read a value from memory and put it into the Value
	// Returns true on success, false on failure
	template <class T>
	inline bool Read(DWORD dwAddress, T& Value)
	{
		return ReadProcessMemory(m_hProcess, reinterpret_cast<LPVOID>(dwAddress), Value, sizeof(T), NULL) == TRUE;
	}
	// Write the Value into the memory
	// Returns true on success, false on failure
	template <class T>
	inline bool Write(DWORD dwAddress, const T& Value)
	{
		return WriteProcessMemory(m_hProcess, reinterpret_cast<LPVOID>(dwAddress), Value, sizeof(T), NULL) == TRUE;
	}
[/CODE]

Nothing really special here. As you can see these are just functions that wraps RPM and WPM using templates.
Finally we can put some getters to conclude the class.

[CODE]
// Getters
HANDLE GetHandle() { return m_hProcess; }
DWORD GetProcId() { return m_dwProcessId; }
std::vector<MODULEENTRY32> GetModules() { return m_Modules; }
[/CODE]

Do I really need comments here?
Remember to implement this class (if using C++) following the classic .h/.cpp separation convention.

Reference links for this section:
[URL="http://pastebin.com/cfF01nEZ"]Commented MMC on pastebin[/URL]

[SIZE="5"][FONT="Franklin Gothic Medium"][B]Chapter 3[/B][/FONT][/SIZE]
[SIZE="4"][FONT="Franklin Gothic Medium"][B]Offsets[/B][/FONT][/SIZE]

One of the most important topics to know while learning about memory hacking is the purpose of an offset. In these chapters I'll try to explain what an offset is and how to use them to access our values in memory. I'll then move into explaining netvars and then I'll talk about how to grab offsets and netvars dynamically.
But first, what is an offset?

An offset is a value that describes how many bytes we should move from the base adress to reach a certain area of memory. Refer to this basic image to understand the concept:

[IMG]http://i.imgur.com/8ZeSlWE.png[/IMG]

We got a base address located at 0x0000, a pointer to local player located at 0x004C and the local player's health which is located at 0x007E. Our objective is to read out the health value of the local player.

Now to reach the local player's pointer we need to move 0x004C away from the base address (since 0x004C - 0x000 = 0x004C) so we would just do a basic RPM call: RPM(base address + 0x004C) where 0x004C is the offset. By using RPM we are dereferencing the pointer located at that address meaning that we got the real local player and not just a pointer to it. To get his health we apply the same concept. 0x007E - 0x004C = 0x0032 meaning that the offset is 0x0032. Now we can just do RPM(local player + 0x0032) to get the health we wanted. Now you may be thinking "what if I just do RPM(0x007E)" since it's a static address? That's correct but remember that we are doing a really basic example. Normally we use the module base address as our base address (client.dll, engine.dll or others) and usually this address is dynamic meaning that it will change at each launch of the game. This means that if the base address changes the whole set of addresses will change also changing the ones we want to reach. But the difference between the local player's pointer and the base address will always be the same, the same [B]offset[/B].

So for CS:GO the current offset for the local player is 0xA323E4 while the module base of client.dll will be dynamic so we can't give a certain value for it (that's why we use that algorithm showed on previous sections).
By doing RPM(base address + 0xA323E4) we get the local player. 0xA323E4 is an offset telling us how many bytes we must move from the base address if we want to reach something in memory. Other examples of offsets are the entity list (0x4A4FCA4) or force jump (0x4EE5114).

[B]Be careful![/B] The current offsets are static values which means that if there is a little change to the code the addresses set will modify and therefore modifying the values of the offsets. On each update the offsets will be most likely outdated. You have to re-grab them using an offset dumper or just implement pattern scanning (which I'll cover later on).

Is m_iHealth (0xFC) an offset? Kinda yes because we use it like the normal offsets but it's more specifically a netvar. I'll cover them also.

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Using our class and the offsets to make our first bhop[/B][/I][/FONT][/SIZE]
[I]
(NOTE: This section is going to get really practical with a lot of commented pieces of C++ source code. But no problems, it's optional! You can skip this if you really want it <3)[/I]

Well, after a little bit of summer VACation I'm back on track writing this piece of "guide". We are back again with another practical lesson which will involve commented sauce which you can test and try on your own (no anti-pasta included, just read that comments ok? :( ).

So remember the MMC (Memory Management Class) we built some lessons ago? Idk how you built it, if you used the exact same structure that I used, if you used more C++11 modern style, or whatever but in the end the logic is always the same: using RPM/WPM wrappers we'll read and write CS:GO memory to get the results we want to achieve with our cheat. In this case we are going to achieve the most basic thing you'll ever want for CS:GO, an automatic bunnyhop software. Many ppl call it "bhop script" but that's not an exact definition since we are reading (and writing if you want) actual CS:GO memory so yeah this is a real program not a script of any sort. Hence why I call it bhop cheat or bhop software.

Before going practical we need to fully understand what we want to achieve and the logic behind it in our mind before writing source code. Everyone here knows what bhopping is, right? For the 2 ppl here who doesn't know anything bhop (Bunny Hop) is a technique that takes advantage of jumping/strafing to gain a lot of speed (we can reach stable ~300 velocity which is a lot). It's really famous on Source based games like CS:GO (it was way more useful and funny on CS:S) but it also works on other kind of games especially arena shooters.

So how shall we proceed to make a program that does the "heavy lifting" of bhopping for us and allowing us to gain speed easily without practicing like a nerd?
At first glance you might think: "What if I just make a program that spams the space key while you are pressing it". I'd say that you can make a macro for that without making a whole software but in the end of the day this method is quite shit and not precise (you won't gain any velocity in most of the cases) especially on servers running at 128 ticks.

Thinking logical, what is the most difficult part of bhopping? Timing the jumping. [I]When we are on ground we have to jump immediately to gain velocity.[/I]. See this sentence? We can translate this logic into actual C++ source code. All we need to know is exactly when we are on ground but how can we do this? Simple: we'll use a special bitflag (stored in CS:GO memory) that holds all kinds of player states: on ground, crouching, zooming, etc. We need to check for when the player is on ground so quite straight-forward. We can start writing sauce!

[CODE]
// First of all include your Memory Management Class. I won't include anything else other than basic C++ i/o because MMC header already includes WinAPI
#include "MemoryManager.h"
#include <iostream> // For STL i/o
#include <ctime> // For std::chrono
#include <thread> // For std::this_thread

int main()
{
    // Main entry point of the program
    return 0;
}
[/CODE]

Depending on your implementation of MMC the approach will be different. In this example I'll use the MMC written on the previous section of the guide.

[CODE]
try {
    CMemoryManager* MemoryManager = new CMemoryManager("csgo.exe");
} catch (...) {
    // Process not found or invalid snap handle, manage the failure safely
    std::cout << "CS:GO not found!" << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(1500)); // Sleep for 1.5 secs so the user can see the error
    return 0; // Quit the program
}
[/CODE]

Now we have got our MemoryManager instance ready to go. We will operate in the client.dll memory section only since all the offsets we need are there.

[CODE]
if (!MemoryManager->GrabModule("client.dll"))
{
    // Client module not found, manage the failure
    std::cout << "Client module not found!" << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(1500)); // Sleep for 1.5 secs so the user can see the error
    return 0; // Quit the program
}
[/CODE]

Now following my implementation we've added client.dll module infos to the m_Modules private member of the MMC. We need the client base address to grab the local player so I'll do smth like this:

[CODE]
DWORD dwClientBase = 0; // This will hold the client base address
for (auto m : MemoryManager->GetModules()) // Loop through the modules grabbed
{
    if (!strcmp(m.szModule, "client.dll"))
    {
        dwClientBase = reinterpret_cast<DWORD>(m.modBaseAddr);
        break;
    }
}
[/CODE]

Even if we've got only one module so far this implementation will allow us to work with many modules with ease. Sorry for the mixture of C++11 practices like enhanced for and reinterpret_cast and C stuff like strcmp and DWORD but this is just demonstrative (worst excuse ever lol)

Now we've got our client base address. Cool, huh? Using the MMC and the local player offset (grabbed from the so-loved [URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/103220-global-offensive-structs-offsets-277.html"]structs/offsets thread[/URL]) we are able to retrieve the address of the local player for our needs.

[CODE]
DWORD dwLocalPlayer = 0; // This will hold our local player base address
MemoryManager->Read<DWORD>(dwClientBase + 0x00A3A43C, dwLocalPlayer); // Dereference the pointer to the local player from process memory and grab the base address value
[/CODE]

Now how we can check if the local player is on ground or not? Each entity has got a member called m_fFlags which is a bitfield located at base + 0x100 (256). We can operate on this member quite easily using our bitfield knownledge (because you've got bitfield knownledge, right?). We can compare stuff using the & operator (bitwise and) and other cool stuff. Read more about bitfields/masks [URL="http://www.learncpp.com/cpp-tutorial/3-8a-bit-flags-and-bit-masks/"]here[/URL].

From the SDK we know that the flag value to check if on ground is [I](1<<0)[/I] ([URL="https://github.com/ValveSoftware/source-sdk-2013/blob/master/mp/src/public/const.h#L110"]FL_ONGROUND[/URL]) so we can stick on it.

[CODE]
// We'll put everything into a while(true) loop later on
// Read m_fFlags out of memory
BYTE fFlags = 0; // This will hold the bitfield
MemoryManager->Read<BYTE>(dwLocalPlayer + 0x100, fFlags);

// Continue only if the user is holding space
if (GetAsyncKeyState(VK_SPACE) & 0x8000)
{
    if (fFlags & (1<<0)) // Check for FL_ONGROUND
    {
        // Continue...
    }
}
[/CODE]

Now we can choose 2 ways. One way will involve using a WPM call to force a jump directly from memory and the other way will involve using the WinAPI to simulate a mouse scroll but the user will have to bind +jump to mouse scroll in game so yeah not completely portable. In this example I'll just stick to memory writing because paranoias in these cases is really (really) useless (CS:GO will just pretend you are not there).

So there is an offset that will work perfectly: m_dwForceJump. Basically, based on the value that m_dwForceJump got the game will either jump, not jump or jump for one tick. This is just what we need! We write 4 to it to reset jump, 5 to jump and 6 to jump for one tick. In order to reduce WPM/RPM calls to minimal writing 6 will be as perfect as writing 5 and then 4 after a small sleep.

[CODE]
MemoryManager->Write(dwClientBase + 0x02E97EC4, 6); // Will force jump for 1 tick
[/CODE]

With this method we can achieve near to perfect hops with minimal effort(holding the space bar lol).
The final code snippet will look something along the lines of this (remember that you'll have to adapt the source based on your MMC implementation!):

[CODE]
// First of all, include your Memory Management Class. I won't include anything else other than basic C++ i/o because MMC header already includes WinAPI
#include "MemoryManager.h"
#include <iostream> // For STL i/o
#include <ctime> // For std::chrono
#include <thread> // For std::this_thread

int main()
{
    // Main entry point of the program
	
	try {
		CMemoryManager* MemoryManager = new CMemoryManager("csgo.exe");
	} catch (...) {
		// Process not found or invalid snap handle, manage the failure safely
		std::cout << "CS:GO not found!" << std::endl;
		std::this_thread::sleep_for(std::chrono::milliseconds(1500)); // Sleep for 1.5 secs so the user can see the error
		return 0; // Quit the program
	}
	
	if (!MemoryManager->GrabModule("client.dll"))
	{
		// Client module not found, manage the failure
		std::cout << "Client module not found!" << std::endl;
		std::this_thread::sleep_for(std::chrono::milliseconds(1500)); // Sleep for 1.5 secs so the user can see the error
		return 0; // Quit the program
	}
	
	DWORD dwClientBase = 0; // This will hold the client base address
	for (auto m : MemoryManager->GetModules()) // Loop through the modules grabbed
	{
		if (!strcmp(m.szModule, "client.dll"))
		{
			dwClientBase = reinterpret_cast<DWORD>(m.modBaseAddr);
			break;
		}
	}
	// TODO:: Add check to see if we didn't find a valid client base ;)
	
	while (true)
	{
		DWORD dwLocalPlayer = 0; // This will hold our local player base address
		MemoryManager->Read<DWORD>(dwClientBase + 0x00A3A43C, dwLocalPlayer); // Dereference the pointer to the local player from process memory and grab the base address value
		
		// TODO:: Add checks to control RPM/WPM failures!
		
		// Read m_fFlags out of memory
		BYTE fFlags = 0; // This will hold the bitfield
		MemoryManager->Read<BYTE>(dwLocalPlayer + 0x100, fFlags);

		// Continue only if the user is holding space
		if (GetAsyncKeyState(VK_SPACE) & 0x8000)
		{
			if (fFlags & (1<<0)) // Check for FL_ONGROUND
			{
				MemoryManager->Write(dwClientBase + 0x02E97EC4, 6); // Will force jump for 1 tick only
			}
		}
		
		// Sleep 10 ms to save CPU
		std::this_thread::sleep_for(std::chrono::milliseconds(10));
	}
	
    return 0;
}
[/CODE]

I've added comments with TODO in sauce that will serve as a little "homework" to you to improve this snippet.
The other homework you have is to make it so it doesn't jump while the chat is open. There are many ways to achieve this just choose one. Search around and you'll always find what you need ;) (in most cases).

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Netvars[/B][/I][/FONT][/SIZE]

Before jumping into pattern scanning I'd like to talk about netvars. A [B]Net[/B]worked [B]Var[/B]iable (netvar) is as the name suggests a variable which is networked. A first example of a netvar would be m_iHealth (0xFC) or m_iTeamNum (0xF0) which are variables that ofc need to be networked in order to make the whole multiplayer thing work you know. 

These special variables are used exactly like any other offset: for example m_iHealth is a member of DT_BasePlayer (DT stands for [B]D[/B]ata [B]T[/B]able, notice the m_i hungarian notation prefix which Valve uses a lot). There are many data tables like DT_CSPlayer, DT_BaseViewModel, etc...

So let's say we want to grab the amount of matchmaking wins of a certain player on the server. The first thing that would come in our mind if we don't know anything would be "There must be a netvar that holds this value!" and that's true: it's called m_iCompetitiveWins and it's an integer value as the convention suggests and yes it's exactly what we want. You try to do smth like RPM(entity base address + m_iCompetitiveWins offset) BUT the result is really fucked up and not exactly what we want. That's because you didn't notice that m_iCompetitiveWins isn't a member of DT_CSPlayer or BasePlayer! Hence why we can't read it as we do with other netvars which are members of that data table. Rewatch the netvar dump carefully and you'll notice that m_iCompetitiveWins is a member of DT_CSPlayerResource so we need to read it differently from what we usually do. Since CSPlayerResource will hold 64 values for each client connected to server meaning that we need the entity index of the player we want to read the wins from. We'll do smth like RPM(player resource base + m_iCompetitiveWins + i * sizeof(int)) where i is the index of our entity and since each member of the array is an integer we do i * sizeof(int) (we could just do i * 4 but ayyyy).

Basically, if we want to grab something from a certain player or the local player itself remember that there will most likely always be a netvar that holds the value we are looking for. Really, there are a shit-ton of netvars so just take the right time to search through the dump and you'll find what you want in most cases. See how a basic netvar dump can be really really useful? In the next section we'll cover pattern scanning and then  how these dumps are made involving recursion... will be really cool stuff indeed! :D

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Getting offsets dynamically: Pattern Scanning[/B][/I][/FONT][/SIZE]

Started from the bottom and now we are here: talking about pattern scanning. This is an important step to make if you want to take your externals to the next levels simply because [B]the only purpose of pattern scanning is to completely eliminate the hassle of updating offsets on each update on the game.[/B]
For example: the offsets I've used previously in the example codenz some weeks ago are already outdated now because of CS:GO updates. In order to make your external more consistent and reduce the work you have to put on it to mantain it you can implement the infamous pattern scanning.

Still this guide is aimed to completely noobish ppl so I don't really want to get any kind of deeper in pattern scanning ([URL="http://www.unknowncheats.me/forum/programming-for-beginners/171994-understanding-pattern-scanning-concept.html"]like WasserEsser did in his awesome guide which I recommend reading after you grasp the concept[/URL]). I just want you to understand how it works and how to implement it in your fantastic ez external cheaterino.

So the concept behind pattern scanning is (basically speaking) to "build the offset" we are going to use later on in the cheat code. Each CS:GO module (like client.dll or engine.dll) is composed of bytes (raw bytes) which can be seen when reversing a module in OllyDbg or any other reversing tool. The offset we need is lying in these bytes because the game itself uses offsets internally to access certain areas of memory (like we do with our externals!). We just have to grab it without forcing it but how? The answer is quite simple: we use the sorrounding bytes of the offsets. See this image taken from WasserEsser guide:

[IMG]http://i.imgur.com/HDlH0AK.png[/IMG]

FC 00 00 00 is m_iHealth (stored in little endian system) which is a common netvar we know to grab the health of an entity. In the image the sorrounding bytes of the offset are highlighted in gray (so you can see them). These bytes are going to compose our pattern. Using OllyDbg specifically we can simply use the SigMaker plugin or if you are really brave you can make the sig on your own just by looking at the bytes (SigMaker just simplifies the process).

In this specific case the signature is "\x75\x09\x83\xB9[B]\xFC\x00\x00\x00\x00\[/B]x7F\x2D". We see that the current offset is lying in the pattern and we don't want it to be there so we nullify it (by just modifying the xFC to x00 in this specific case). Now we have got the pattern we need. The mask is just derived from the pattern: it's a string describing which byte is known and which byte isn't known. In this case:

x75\ -> x
x09\ -> x
x83\ -> x
xB9\ -> x
x00\ -> ?
x00\ -> ?
x00\ -> ?
x00\ -> ?
x00\ -> ?
x7F\ -> x
x2D\ -> x

So the final mask is "xxxx?????xx". Simple, huh? With the pattern and the mask in our hands we can proceed to make our pattern scanning implementantion in C++ code.
To understand how the algorithm is going to work just look at this picture:

[IMG]http://i.imgur.com/OWAG2k2.png[/IMG]

This horrific thing made in paint in 2 mins represents how the pattern scanning is going to work with module bytes. Basically, in the image we have got 4 possible places to place our pattern. We loop through all of the possible places until we find the only one that fits our pattern (the third one obviously). Now you may ask "What if I encounter a fitting place but it's not where my offset is lying?". That can happen (but it's really not that likely...) and that's why we want to make patterns as unique as possible. Also we don't want them to be too long or too short because a too long pattern will get outdated in less time than a good sized pattern. In the end it's way better than hardcoding offsets.
That's also how the offsets dumper we commonly use to grab offsets work: each one with a different kind of implementation. Just like with MMC (Memory Management Class, remember?): the code style possibilities are really wide so my commented implementation will be just a small example to let you understand, nothing more.

In order to do pattern scanning I commonly use a class...
[CODE]
// This is the skeleton of the class
class CScanner
{
protected:
	HANDLE* m_pHandle; 						// A pointer to a valid handle (to CS:GO ofc)
	DWORD 	m_dwModuleBase; 				// Base of the module we want to scan
	DWORD 	m_dwModuleSize;					// Size of the module we want to scan
	std::unique_ptr<BYTE[]> m_pModuleBytes;	// Bytes of the module
public:
	// Here I'm going to define the scanning functions
};
[/CODE]

The members of the class are quite obvious and that's all we need. The first step is to dump the module bytes which means storing the whole module into a byte array. Yeah that sounds crazy. It is actually considering that a module is really really heavy (just log the module size of client.dll or engine.dll). This means that we need to take care of memory leaks because if we leak this huge amount of memory that's not a good thing. At all. That's why I'm using the STL type std::unique_ptr. It's a C++11 thing that allows me to make a smart pointer which will delete itself when it gets out of scope (when we delete a class instance in this case). Kinda handy, huh? It will take care of avoiding memory leaks (hopefully) but you can do whatever you want.

[WORK IN PROGRESS ===== ADDING THE CODE]

[B][I]...WORK IN PROGRESS...[/I][/B]

This guide as I already said is not complete and still needs a lot of work. I'll update it with new sections and chapters when time goes by but you can help me updating/correcting/improve this guide using this [URL="https://github.com/DoubleHub/CSGOCheatMaking101/blob/master/Guide.txt"]GitHub repo[/URL].
