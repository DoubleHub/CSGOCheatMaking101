[SIZE="6"][FONT="Franklin Gothic Medium"][B]CS:GO Cheat Making 101[/B][/FONT][/SIZE]
[B][I]
NOTE: This guide is still a HUGE work in progress. You can use the GitHub repo to push commits in order to modify and update this guide. Your help is important! [URL="https://github.com/DoubleHub/CSGOCheatMaking101/blob/master/Guide.txt"]*CLICK*[/URL][/I][/B]

[B][I]Structure of the guide:[/I][/B] (prone to changes)
[B]Chapter 0[/B] ~ Welcome to CS:GO Cheat Making 101! The requirements
[B]Chapter 1[/B] ~ Explaining CS:GO
[I]Chapter 1.1[/I] ~ Brief introduction to the Source Engine
[I]Chapter 1.2[/I] ~ Different types of cheats
[I]Chapter 1.3[/I] ~ Talking about VAC: Ring0 and Ring3
[B]Chapter 2[/B] ~ External Cheats: The starting point
[I]Chapter 2.1[/I] ~ Brief introduction to WinAPI
[I]Chapter 2.2[/I] ~ Managing CS:GO memory: RPM and WPM
[I]Chapter 2.3[/I] ~ Getting CS:GO module info
[I]Chapter 2.4[/I] ~ Building a memory management class
[B]Chapter 3[/B] ~ Offsets
[I]Chapter 3.1[/I] ~ Using our class and the offsets to make our first bhop
[I]Chapter 3.2[/I] ~ Netvars
[I]Chapter 3.3[/I] ~ Getting offsets dynamically: Pattern Scanning
[I]Chapter 3.4[/I] ~ Getting netvars dynamically: Netvar Managers and recursion
[B]Chapter 4[/B] ~ Internal Cheats: The advantages
[I]Chapter 4.1[/I] ~ Calling exported module functions
[I]Chapter 4.2[/I] ~ CreateInterface: Getting those interfaces
[I]Chapter 4.3[/I] ~ Hooking methods: VMT hooking
[I]Chapter 4.4[/I] ~ A look at the Source SDK
[I]Chapter 4.5[/I] ~ Common functions to hook
[I]Chapter 4.6[/I] ~ A look at CreateMove: Making our first internal bhop
[I]Chapter 4.7[/I] ~ Drawing using ISurface

[SIZE="5"][FONT="Franklin Gothic Medium"][B]Chapter 0[/B][/FONT][/SIZE]
[SIZE="4"][FONT="Franklin Gothic Medium"][B]Welcome to CS:GO Cheat Making 101! The requirements[/B][/FONT][/SIZE]

Hi and welcome to CS:GO Cheat Making 101, a "all-in-one" guide for CS:GO cheat making! Please notice that this guide is still a huge work in progress and it is prone to changes. Since I'm not really pro when it comes to CS:GO cheat making, I'd like you guys to help me building this guide and expanding it as large as possible. I'll cover a lot (but not all) of aspects of CS:GO cheats and I'll try to be as clear as possible.

Now, let's take a look at the requirements for this guide. I see many people here trying to approach CS:GO cheat making (in various languages) just to make cheats for them. I mean, that's great, you want to learn, but that's not the right approach. If you have absolutely 0 knownledge of programming in general, following this guide will be really difficult, so from you I want to at least know one programming language and being able to think in terms of programming, you know what I mean.
Some people here even learnt a programming language by making CS:GO cheats, still it will be really difficult if you don't have a certain "mindset" ready.

I'm not writing this guide with the purpose of showing my (near to no) knownledge about this stuff. I'm writing this guide as a starting point to many ppl out there trying to start in this sector. As I said some months ago, all I needed when I started here was a really solid base to learn from. In order to make this guide the best and the most complete guide about CS:GO cheat making, I need your help. The help of people with a real huge experience in this sector, that would be really great and you'll sort of help this community. :asskiss:

[SIZE="5"][FONT="Franklin Gothic Medium"][B]Chapter 1[/B][/FONT][/SIZE]
[SIZE="4"][FONT="Franklin Gothic Medium"][B]Explaining CS:GO[/B][/FONT][/SIZE]

[B]C[/B]ounter [B]S[/B]trike: [B]G[/B]lobal [B]O[/B]ffensive (aka CS:GO), as many of you know, is a first person shooter game with a lot of focus on the competitive aspect. The game requires a certain set of skills and ability to pwn your enemies, and when it comes to skill we all know that... we'll come to cheats! CS:GO is probably one of the most (if not the most) full of cheaters paid game, and the creators (Valve + Hidden Path Entertainment) can't do anything for it. Throughout the various updates of the game, they've released several ways and workarounds to trying stopping cheaters (always failing), but in the end we all know that they won't stop cheaters, for obvious money reasons. Getting a cheap CS:GO copy is really easy, as it is really easy to cheat. There are near to no protections compared to other paid games (well, don't take me wrong, there are some cheap protections like untrusted checks but...) and the community itself is full of cheaters. Just for example, this section of UC is probably one of the most visited and active UC sections (mods, get ready to prove the opposite).

But we are not here to talk about how full of cheaters CS:GO is, we are here to learn about making a cheat! This forum is full of references, tutorials, sources about how to make certain stuff for CS:GO, infact I'll put at the end of each chapter a little list of reference links which I really recommend to read to get deeper on the concept explained in the chapter.

Reference links for this section:
[url]http://www.unknowncheats.me/wiki/Counter-Strike:_Global_Offensive[/url]
[url]https://en.wikipedia.org/wiki/Counter-Strike:_Global_Offensive[/url]
[url]https://en.wikipedia.org/wiki/Valve_Corporation[/url]
[url]https://en.wikipedia.org/wiki/Hidden_Path_Entertainment[/url]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Brief introduction to the Source Engine[/B][/I][/FONT][/SIZE]

CS:GO runs on the Source Engine, a really famous game engine used to make a lot of games that we all know and love (a prime example is Half Life or Left 4 Dead).
The Source is well known for his great physics system (that we saw in action in HL) but in general it is a great engine to make games on. Another great advantage is his flexibility, which makes the life of modders way easier.

It is greatly documented on internet and here, and it's (only in part) open source. This allows us to get a shit-ton of info about the game itself without needing to reverse it completely (don't get me wrong, you'll still need to reverse it on certain situations).
Since CS:GO is built upon the Source Engine, a large part of what we'll do to modify the game (to get an advantage) is related to it, especially when we are going internal.

Reference links for this section:
[url]http://www.unknowncheats.me/wiki/Source_Engine[/url]
[url]https://en.wikipedia.org/wiki/Source_(game_engine)[/url]
[url]https://developer.valvesoftware.com/wiki/SDK_Docs[/url]
[url]https://github.com/ValveSoftware/source-sdk-2013[/url]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Different types of cheats[/B][/I][/FONT][/SIZE]

Before getting into cheat making, it's important to know what are we going to do.
Usually (not only for CS:GO) there are 2 types of cheats: Internals and Externals.
The difference between those two types is huge:

An [B]EXTERNAL[/B] cheat is an [B]EXE[/B] which is able, through an HANDLE (think it like a bridge) to CS:GO process, to read and write memory. By reading and writing certain areas of memory we are able to make our cheats.
The main disadvantage of externals is the fact that we are not in sync with the game's thread, which can lead to "unexpected" results (a prime example are external skinchangers, since they are not in sync with the game's thread you won't achieve consistency especially when trying to change the knife model).
We are also forced to read and write through specific functions (we'll see later) that are heavy to call.

An [B]INTERNAL[/B] cheat is a [B]DLL[/B] which is injected directly into CS:GO and it is able to directly read and write CS:GO memory, through raw pointers. Internally, we can also get interfaces and call virtual functions, which makes our lives way easier. We can also hook some functions to kind of "redirect" them and make them doing what we want.

There is still an open discussion about what type of cheat is the most detectable.

There is another type of cheat, called "Internal/External", which is basically a DLL which is injected into any 32-bit process and from there it operates like a normal external. I think that we can consider this type of cheat external, because in the end all the operations we do are the same as external and we don't do anything internal.

We'll start with external, which are easier to learn but hard to master, while internal cheats are hard to learn... but easy to master!

Reference links for this section:
[URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/151797-ezfrags-cs-multihack-public-rage-legit.html"]An example of an external cheat (EZFrags)[/URL]
[URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/183376-fx-cs-public-release.html"]An example of an internal cheat (FX)[/URL]
[URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/159299-internal-external-customizable-multi-hack.html"]An example of an internal/external cheat[/URL]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Talking about VAC: Ring0 and Ring3[/B][/I][/FONT][/SIZE]
[I]
(NOTE: I may say something wrong or bullshit in this specific section. VAC experts and kernel mode experts, help me! <3)[/I]

The main anticheat that CS:GO is using is the [B]V[/B]alve [B]A[/B]nti-[B]C[/B]heat (aka VAC), which is supposed to block cheaters but we all know that it fails miserably. Basically, the VAC is a joke. You don't need to be too much afraid of it since it won't bust you if you aren't using a public cheat. The VAC is using signature scanning in order to detect cheats. When a cheat becomes detected by VAC it means that the VAC detected his signature (which is an unique identifier for something) and stored it in his database. When you are using a cheat with a detected signature, you are fucked (flagged).
VAC bans are completely automatic and can take a lot of time to ban you, because it needs to know 100% that you are cheating, in order to avoid false positives.

You have to know about Ring0 and Ring3 to get a feeling about how VAC is a real joke. Basically, Intel processors (x86 but also others) to protect critical resources like IO, memory, ports, etc provide some privilege levels (0 being most privilege and 3 being last) aka UserMode and KernelMode.
So, the OS runs kernel code in Ring0, and user code in Ring3.
VAC operates in Ring3. Basically, if you make a Ring0 cheat you are good to go. But if you are capable of making a Ring0 cheat then all of this stuff should be a piece of cake at your eyes, you can leave.

Reference links for this section:
[url]https://en.wikipedia.org/wiki/Valve_Anti-Cheat[/url]
[url]http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection/[/url]
[url]https://en.wikipedia.org/wiki/Protection_ring[/url]

[SIZE="5"][FONT="Franklin Gothic Medium"][B]Chapter 2[/B][/FONT][/SIZE]
[SIZE="4"][FONT="Franklin Gothic Medium"][B]External Cheats: The starting point[/B][/FONT][/SIZE]

We'll focus, for now, on external cheats, which you now know what they do (ref: 1.2 Different types of cheats)
Writing external cheats serves as a really good starting point in this sector because externals are way more documented than internals and they are way easier to code and understand.
However, once you get a really good grip on this type of cheat, you should consider switching internal which is (imho) fairly better. Still, you need the right knownledge.

As I already explained, the purpose of external cheats is reading and writing the CS:GO memory in order to edit it, gain info and get a huge advantage over our enemies in game.
An external cheat, however, isn't forced to manage CS:GO memory. For example, you can write a really good recoil control system (aka RCS) without needing to read or write anything. Still, the most consistent results can be achieved only by reading/writing memory. For example, you can make a bhop script that spams the space key without reading or writing any sector of memory, still the hops won't be consistent and the result can be shit. On the other side, by reading the memory to know exactly when to jump, you can achieve the consistency you want.
In the end, it's all a matter of consistency.

Reference links for this section:
[URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/147103-peans-ahk-triggerbot-aka-colorbot-extension.html"]An example of color triggerbot, not interacting with CS:GO memory[/URL]
[URL="http://www.unknowncheats.me/forum/counterstrike-global-offensive/168179-simple-bunny-hop-script.html"]An example of a really basic bhop, interacting with CS:GO memory (by me)[/URL]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Brief introduction to the WinAPI[/B][/I][/FONT][/SIZE]

I've stated multiple times that we need to manage CS:GO memory in order to achieve certain results with our external cheats. But how? The answer has got a name: The [B]Win[/B]dows [B]A[/B]pplication [B]P[/B]rogramming [B]I[/B]nterface! (aka WinAPI)

The Windows OS allows us to use the WinAPI, which (basically speaking) is a set of C functions and structs implemented in [B]D[/B]ynamic [B]L[/B]ink [B]L[/B]ibraries (aka DLL). Don't get me wrong, you can still mix your C++ code style with the usage of WinAPI.
There are, as you may know, three main groups of API: Kernel, [B]G[/B]raphics [B]D[/B]evice [B]I[/B]nterface (aka GDI) and User. You can find more infos about those 3 types on the reference links I'm going to provide, if you want to get deeper.

Now that we know what we are going to mainly use in our externals, we can start talking about practically managing the CS:GO memory!

Reference links for this section:
[url]https://en.wikipedia.org/wiki/Windows_API[/url]
[url]https://msdn.microsoft.com/en-us/library/cc433218(VS.85).aspx[/url]
[url]http://www.infernodevelopment.com/c-win32-api-tutorial[/url]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Managing CS:GO memory: RPM and WPM[/B][/I][/FONT][/SIZE]

We're going to use a lot of stuff from the WinAPI to get the results we want, and for sure the functions that we are going to use the most are the actual functions to read and write process memory.
Those two functions are [B]R[/B]ead[B]P[/B]rocess[B]M[/B]emory and [B]W[/B]rite[B]P[/B]rocess[B]M[/B]emory (aka RPM and WPM).
Let's see how we work with these two functions, I'll start with ReadProcessMemory.
Based on the MSDN page of RPM, the function prototype is:

[CODE]
BOOL WINAPI ReadProcessMemory(
  _In_  HANDLE  hProcess,
  _In_  LPCVOID lpBaseAddress,
  _Out_ LPVOID  lpBuffer,
  _In_  SIZE_T  nSize,
  _Out_ SIZE_T  *lpNumberOfBytesRead
);
[/CODE]

[I]"_In_  HANDLE  hProcess"[/I]

The first argument, the hProcess, is the actual [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724176(v=vs.85).aspx"]HANDLE[/URL] to the process we need to read memory from. Remember what I said in 1.2? In external cheats we use an HANDLE (like a bridge) to read and write memory.
In order to get this HANDLE you've got several ways. 
The most used way is to loop through all the process through [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684836(v=vs.85).aspx"]Process32Next[/URL] (and [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684834(v=vs.85).aspx"]Process32First[/URL]), using the helper struct [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684839(v=vs.85).aspx"]PROCESSENTRY32[/URL], then in the loop comparing the current process name with the process name we are searching for, if the names are the same then we use the WinAPI function [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684320(v=vs.85).aspx"]OpenProcess[/URL] to open an handle to this process. Notice that, in order to be able to read and write, we will put the flag [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684880(v=vs.85).aspx"]PROCESS_ALL_ACCESS[/URL] in order to gain full privileges.

[B]REMEMBER! An HANDLE must always be closed through [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms724211(v=vs.85).aspx"]CloseHandle[/URL] once it's not used anymore![/B]

This, however, is not the only way, of course. For example, if we are using managed languages like C# or VB.NET, there are way easier ways. However, I've explained the most common one.

The other arguments are already well explained on the MSDN page, and we'll later see how we'll use the second argument with module base addresses and offsets.

WPM has got the same arguments, the only difference is that the third argument is a pointer pointing to the value we want to write, while in RPM is a pointer pointing to the variable that is gonna receive the value read from memory.

RPM and WPM are not the only way to read and write process memory, it's just the most common one, since it's well documented and already implemented by the WinAPI itself. CS:GO doesn't detect WPM and RPM since a lot of legit processes use them constantly, and the anticheat (as I already stated) wants to avoid false positives.

Reference links for this section:
[URL="http://pastebin.com/Bd6t5tcP"]Commented example of a common function to open an handle to a process (using WinAPI)[/URL]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Getting CS:GO module infos[/B][/I][/FONT][/SIZE]

One of the most useful things we can do in CS:GO memory is grabbing infos about a specific module (a DLL, like client.dll or engine.dll, but also others). When we'll get into offsets, you'll see how important is to know some stuff about different CS:GO modules. But how can we grab this useful info?
As always, there are several methods, one is really similar to the method that I've explained previously about opening the process handle. The only difference is that instead of using [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684839(v=vs.85).aspx"]PROCESSENTRY32[/URL] and related funcs like [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684834(v=vs.85).aspx"]Process32First[/URL] and [URL="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684836(v=vs.85).aspx"]Process32Next[/URL], you have to use [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684225(v=vs.85).aspx"]MODULEENTRY32[/URL] to store info and [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684218(v=vs.85).aspx"]Module32First[/URL]/[URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684221(v=vs.85).aspx"]Next[/URL] to loop through the module list.

Another way is to use the [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms684229(v=vs.85).aspx"]MODULEINFO[/URL] structure and [URL="https://msdn.microsoft.com/it-it/library/windows/desktop/ms683201(v=vs.85).aspx"]GetModuleInformation[/URL] function, really handy when it comes to this kind of stuff.

Now that we got the info that we want, we can use the base address of the module to access specific things (using offsets) in that module (we'll see, for example, grabbing the local player, or the local player health value).
Another useful thing to know is the module size, we'll see his importance when we'll talk about pattern scanning.

Reference links for this section:
[URL="http://pastebin.com/GC9kTHcJ"]Commented example of a common function to get module info (using WinAPI)[/URL]

[SIZE="3"][FONT="Franklin Gothic Medium"][I][B]Building a memory management class[/B][/I][/FONT][/SIZE]
[I]
(NOTE: This section is going to get really practical, with a lot of commented pieces of C++ source code. But no problems, it's optional! You can skip this if you really want it <3)[/I]

Now that you know what we need to do in order to have fun within CS:GO memory, you can take it a step further and start to code an actual class to make everything easier to do. Our goal is to make a memory management class (aka MMC) that allows us to attach to a specific process and grab modules. It's also going to contain some useful template wrappers to WPM and RPM so everything is going to be easier.

Don't take me wrong, you don't actually NEED this kind of class, you can just go ahead and use raw RPM/WPM or just build the functions and use them without using a class, but imho setting it up using OOP is going to help us.
In this guide I'm going to use C++ as an example language, but that's not a problem since you can do the really same things (with some little changes :P) using other languages like C#.

So, let's go ahead, this class is going to contain some members, ofc!

[CODE]
class CMemoryManager
{
private: // Private members: We are going to setup some getters later on!
	HANDLE m_hProcess; // The HANDLE to the process to attach
	DWORD m_dwProcessId; // The Process Id of the process to attach
	std::vector<MODULEENTRY32> m_Modules; // std::vector containing all the modules we grab from the process
[/CODE]

As you can see we've got [I]m_hProcess[/I] which is basically the HANDLE to the process to attach, [I]m_dwProcessId[/I] which is the process id of the process to attach and a basic std::vector of MODULEENTRY32 structs which is going to contain all the modules we grab from the attached process. We use an std::vector so it's easier to push back new elements (modules) without worrying too much about fixed sizes.
Now, let's make the public functions:

[CODE]
        // Attach to a process based on strProcessName
	// Returns true on success, false on failure
	bool Attach(const std::string& strProcessName)
	{
	    // First of all we create a snapshot handle specific for processes
	    // (notice the usage of TH32CS_SNAPPROCESS) so we are able to call Process32First/Next
	    // Remeber to close it when you don't use it anymore!
	    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	    // Check if the snapshot created is valid
	    if (hSnapshot == INVALID_HANDLE_VALUE) return false;
	   
	    // Create the helper struct that will contain all the infos about the current process
	    // while we loop through all the running processes
	    PROCESSENTRY32 ProcEntry;
	    // Remember to set the dwSize member of ProcEntry to sizeof(PROCESSENTRY32)
	    ProcEntry.dwSize = sizeof(PROCESSENTRY32);
	   
	    // Call Process32First
	    if (Process32First(hSnapshot, &ProcEntry))
	    {
	        // Notice that you have to enable Multi-Byte character set in order
	        // to avoid converting everything.
	        // strcmp is not the only way to compare 2 strings ofc, work with your imagination
	        if (!strcmp(ProcEntry.szExeFile, ProcessName.c_str()))
	        {
	            // If we are here it means that the process has been found, we can
	            // open an handle to it and return it
	            // But first of all we have to close the snapshot handle!
	            CloseHandle(hSnapshot);
	            // Open an handle and set the m_hProcess member using OpenProcess
	            // (Notice the usage of PROCESS_ALL_ACCESS flag in order to grant read/write privileges)
	            m_hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcEntry.th32ProcessID);
	            // Store the process id into m_dwProcessId
	            m_dwProcessId = ProcEntry.th32ProcessID);
	            // Return true meaning success
	            return true;
	        }
	    }
	    else
	    {
	        // If the Process32First call failed, it means that there is no
	        // process running in the first place, we can return directly.
	        CloseHandle(hSnapshot);
	        return false;
	    }
	   
	    // If we are here it means that the Process32First call returned TRUE, but the first process
	    // wasn't the process that we were searching for. Now we can loop through the processes
	    // using Process32Next
	    do
	    {
	        // We do the same check we did for Process32First
	        if (!strcmp(ProcEntry.szExeFile, ProcessName.c_str()))
	        {
	            // If we are here it means that the process has been found, we can
	            // open an handle to it and set the m_hProcess member using OpenProcess
	            // (Notice the usage of PROCESS_ALL_ACCESS flag in order to grant read/write privileges)
	            m_hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcEntry.th32ProcessID);
	            // Store the process id into m_dwProcessId
	            m_dwProcessId = ProcEntry.th32ProcessID);
	            // Return true meaning success
	            return true;
	        }
	    }
	    while (Process32Next(hSnapshot, &ProcEntry));
	    // Continue loop while the Process32Next call returns TRUE meaning that there are still processes to check
	   
	    // If we are here it means that the process has not been found or that there are no processes to scan for anymore.
	    // We can close the snapshot handle and return false.
	    CloseHandle(hSnapshot);
	    return false;
	}
[/CODE]

Since I'm using C++ and WinAPI, I'm using the exact same algorithm showed on the previous sections with some little modifies to the return values and comments.
The same thing can be done with the function to grab a new module from the process:

[CODE]
// Grabs a module and adds it to m_Modules if found based on strModuleName
	// Returns true on success, false on failure
	bool GrabModule(const std::string& strModuleName)
	{
	    // First of all we create a snapshot handle specific for modules
	    // (notice the usage of TH32CS_SNAPMODULE) so we are able to call Module32First/Next
	    // Remeber to close it when you don't use it anymore!
	    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, m_dwProcessId);
	    // Check if the snapshot created is valid
	    if (hSnapshot == INVALID_HANDLE_VALUE) return false;
	   
	    // Create the helper struct that will contain all the infos about the current module
	    // while we loop through all the loaded modules
	    MODULEENTRY32 ModEntry;
	    // Remember to set the dwSize member of ModEntry to sizeof(MODULEENTRY32)
	    ModEntry.dwSize = sizeof(MODULEENTRY32);
	   
	    // Call Module32First
	    if (Module32First(hSnapshot, &ModEntry))
	    {
	        // Notice that you have to enable Multi-Byte character set in order
	        // to avoid converting everything.
	        // strcmp is not the only way to compare 2 strings ofc, work with your imagination
	        if (!strcmp(ModEntry.szModule, ModuleName.c_str()))
	        {
	            // If we are here it means that the module has been found, we can add the module to the vector
	            // But first of all we have to close the snapshot handle!
	            CloseHandle(hSnapshot);
	            // Add ModEntry to the m_Modules vector
	            m_Modules.push_back(ModEntry); // You can add a check here to see if the module is already there ;)
	            // Return true meaning success
	            return true;
	        }
	    }
	    else
	    {
	        // If the Process32First call failed, it means that there is no
	        // process running in the first place, we can return directly.
	        CloseHandle(hSnapshot);
	        return false;
	    }
	   
	    // If we are here it means that the Module32First call returned TRUE, but the first module
	    // wasn't the module that we were searching for. Now we can loop through the modules
	    // using Module32Next
	    do
	    {
	        // We do the same check we did for Module32First
	        if (!strcmp(ModEntry.szModule, ModuleName.c_str()))
	        {
	            // If we are here it means that the module has been found, we can add the module to the vector
	            // But first of all we have to close the snapshot handle!
	            CloseHandle(hSnapshot);
	            // Add ModEntry to the m_Modules vector
	            m_Modules.push_back(ModEntry); // You can add a check here to see if the module is already there ;)
	            // Return true meaning success
	            return true;
	        }
	    }
	    while (Module32Next(hSnapshot, &ModEntry));
	    // Continue loop while the Module32Next call returns TRUE meaning that there are still modules to check
	   
	    // If we are here it means that the module has not been found or that there are no modules to scan for anymore.
	    // We can close the snapshot handle and return false.
	    CloseHandle(hSnapshot);
	    return false;
	}
[/CODE]

As you can see it's the exact same algorithm with some little modifications! Again, this isn't the only way to do this, depending on what you are using.

Now that we've got the core functions that will perform the algorithms we need, we can build our constructor which will initialize the class. As always everything is pretty straight forward and commented.

[CODE]
        // Default constructor: won't attach to any process
	CMemoryManager()
	{
		// Init members
		m_hProcess = INVALID_HANDLE_VALUE;
		m_dwProcessId = 0;
		// Just for safety, I clear out the modules vector
		m_Modules.clear();
	}
	// This constructor will attach to a specific process (default CS:GO)
	CMemoryManager(const std::string& strProcessName = "csgo.exe")
	{
		// Init members
		m_hProcess = INVALID_HANDLE_VALUE;
		m_dwProcessId = 0;
		// Just for safety, I clear out the modules vector
		m_Modules.clear();
		// Attach and throw if the function failed so we can manage the fail
		if (!Attach(strProcessName))
			throw;
	}
[/CODE]

Now we can start writing our RPM/WPM wrappers, I'll stay simple for now but you can get further by adding things like reading a fixed size of memory, reading an array and returning a pointer to it, and so on... just use your imagination! :)

[CODE]
// RPM/WPM wrappers
	
	// Read a value from memory and put it in Value
	// Returns true on success, false on failure
	template <class T>
	inline bool Read(DWORD dwAddress, T& Value)
	{
		return ReadProcessMemory(m_hProcess, reinterpret_cast<LPVOID>(dwAddress), Value, sizeof(T), NULL) == TRUE;
	}
	// Write a Value in memory
	// Returns true on success, false on failure
	template <class T>
	inline bool Write(DWORD dwAddress, const T& Value)
	{
		return WriteProcessMemory(m_hProcess, reinterpret_cast<LPVOID>(dwAddress), Value, sizeof(T), NULL) == TRUE;
	}
[/CODE]

Nothing really special here, as you can see these are just functions that wraps RPM and WPM using templates.
Finally, we can put some getters to conclude the class.

[CODE]
// Getters
HANDLE GetHandle() { return m_hProcess; }
DWORD GetProcId() { return m_dwProcessId; }
std::vector<MODULEENTRY32> GetModules() { return m_Modules; }
[/CODE]

Do I really need comments here?
Remember to implement this class (if using C++) following the classic .h/.cpp separation convention.

Reference links for this section:
[URL="http://pastebin.com/cfF01nEZ"]Commented MMC on pastebin[/URL]

[B][I]...WORK IN PROGRESS...[/I][/B]

This guide, as I already said, is not complete and still needs a lot of work. I'll update it with new sections and chapters throughout these days. You can help me updating/correcting/getting better this guide using his [URL="https://github.com/DoubleHub/CSGOCheatMaking101/blob/master/Guide.txt"]GitHub repo[/URL].
